<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Separate Instruments</title>
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=DM+Mono:ital,wght@0,300;0,400;0,500;1,300&family=DM+Sans:wght@300;400;500&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/@tonejs/midi/build/Midi.js"></script>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg:       #09090b;
    --s1:       #111114;
    --s2:       #17171c;
    --border:   #222228;
    --border2:  #2e2e38;
    --accent:   #c8f060;
    --text:     #e2e2ee;
    --muted:    #52526a;
    --muted2:   #38384a;
    --ff-title: 'Bebas Neue', sans-serif;
    --ff-mono:  'DM Mono', monospace;
    --ff-body:  'DM Sans', sans-serif;
  }

  html, body { min-height: 100%; background: var(--bg); color: var(--text); font-family: var(--ff-body); }

  body::after {
    content: ''; position: fixed; inset: 0; pointer-events: none; z-index: 9999;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.035'/%3E%3C/svg%3E");
  }

  .orb { position: fixed; border-radius: 50%; filter: blur(130px); pointer-events: none; z-index: 0; }
  .orb-a { width: 700px; height: 700px; top: -250px; left: -200px; background: radial-gradient(circle, rgba(200,240,96,.05) 0%, transparent 70%); }
  .orb-b { width: 500px; height: 500px; bottom: -150px; right: -150px; background: radial-gradient(circle, rgba(96,208,240,.04) 0%, transparent 70%); }

  .shell {
    position: relative; z-index: 1;
    max-width: 760px;
    margin: 0 auto;
    padding: 28px 24px 100px;
  }

  header { display: flex; align-items: baseline; justify-content: space-between; margin-bottom: 40px; }

  .logo {
    font-family: var(--ff-title);
    font-size: 2.6rem;
    letter-spacing: .1em;
    line-height: 1;
    color: var(--accent);
    text-decoration: none;
    transition: opacity .15s;
  }
  .logo:hover { opacity: 0.8; }
  .logo em { color: var(--text); font-style: normal; }

  .inspired {
    font-family: var(--ff-mono);
    font-size: .6rem;
    color: var(--muted);
    letter-spacing: .1em;
  }
  .inspired a { color: var(--muted); text-decoration: underline; text-underline-offset: 3px; }
  .inspired a:hover { color: var(--accent); }

  .groups { display: flex; flex-direction: column; gap: 4px; }

  .group-row {
    display: flex; align-items: center; gap: 16px;
    padding: 13px 18px;
    background: var(--s1);
    border: 1px solid var(--border);
    border-radius: 10px;
    transition: border-color .2s, background .2s;
  }
  .group-row.playing { border-color: var(--accent); background: rgba(200,240,96,.04); }

  .indicator {
    width: 6px; height: 6px; border-radius: 50%;
    background: var(--border2); flex-shrink: 0; transition: background .2s;
  }
  .group-row.playing .indicator { background: var(--accent); box-shadow: 0 0 6px var(--accent); animation: pulse 1s infinite; }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

  .group-name {
    font-family: var(--ff-title);
    font-size: 1.1rem;
    letter-spacing: .08em;
    color: var(--muted);
    width: 160px; flex-shrink: 0;
    transition: color .2s;
  }
  .group-row.playing .group-name { color: var(--accent); }

  .instruments {
    font-family: var(--ff-mono);
    font-size: .62rem;
    color: var(--muted2);
    letter-spacing: .06em;
    flex: 1;
  }
  .group-row.playing .instruments { color: var(--muted); }

  .btn {
    font-family: var(--ff-mono);
    font-size: .6rem;
    letter-spacing: .12em;
    padding: 7px 16px;
    border: 1px solid var(--border2);
    border-radius: 7px;
    background: transparent;
    color: var(--muted);
    cursor: pointer;
    transition: border-color .15s, color .15s, background .15s;
    flex-shrink: 0;
  }
  .btn:hover { border-color: var(--accent); color: var(--accent); }
  .group-row.playing .btn { border-color: var(--accent); color: var(--accent); }
  .group-row.playing .btn:hover { background: var(--accent); color: #09090b; }

  .loading { font-family: var(--ff-mono); font-size: .7rem; color: var(--muted); letter-spacing: .1em; }

  /* Bottom bar */
  #bottom-bar {
    position: fixed; bottom: 0; left: 0; right: 0;
    background: rgba(9,9,11,.92);
    backdrop-filter: blur(12px);
    border-top: 1px solid var(--border);
    padding: 14px 28px;
    display: flex; align-items: center; gap: 18px;
    z-index: 100;
  }

  #now-playing {
    font-family: var(--ff-title);
    font-size: 1rem;
    letter-spacing: .1em;
    color: var(--muted);
    width: 160px; flex-shrink: 0;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    transition: color .2s;
  }
  #now-playing.active { color: var(--accent); }

  #progress-wrap {
    flex: 1; height: 3px; background: var(--border2);
    position: relative; cursor: pointer; border-radius: 2px;
  }
  #progress-wrap::before { content: ''; position: absolute; top: -10px; bottom: -10px; left: 0; right: 0; }
  #progress-bar { height: 100%; background: var(--accent); width: 0%; transition: width 0.1s linear; border-radius: 2px; pointer-events: none; }
  #scrubber { position: absolute; top: 50%; transform: translate(-50%,-50%); width: 10px; height: 10px; border-radius: 50%; background: var(--accent); opacity: 0; transition: opacity .15s; pointer-events: none; }
  #progress-wrap:hover #scrubber { opacity: 1; }

  #time-display {
    font-family: var(--ff-mono);
    font-size: .6rem;
    letter-spacing: .1em;
    color: var(--muted);
    width: 90px; text-align: right; flex-shrink: 0;
    transition: color .2s;
  }
  #time-display.active { color: var(--accent); }
</style>
</head>
<body>
<div class="orb orb-a"></div>
<div class="orb orb-b"></div>

<div class="shell">
  <header>
    <a href="../index.html" class="logo">Music <em>Split</em></a>
    <span class="inspired">Inspired by <a href="https://bandle.app" target="_blank">bandle.app</a></span>
  </header>
  <div id="app"><p class="loading">Loading...</p></div>
</div>

<div id="bottom-bar">
  <div id="now-playing">—</div>
  <div id="progress-wrap"><div id="progress-bar"></div><div id="scrubber"></div></div>
  <div id="time-display">00:00 / 00:00</div>
</div>

<script>
// ── UTILS ──────────────────────────────────────────────────────────────────
function getRole(program, isPercussion) {
    if (isPercussion) return "Drums"
    if (program >= 32 && program <= 39) return "Bass"
    if (program >= 24 && program <= 31) return "Guitar"
    if (program >= 40 && program <= 46) return "Strings"
    if (program === 47) return "Percussion"
    if (program >= 48 && program <= 51) return "Ensemble"
    if (program >= 52 && program <= 54) return "Choir"
    if (program === 55) return "Percussion"
    if (program >= 56 && program <= 71) return "Brass/Wind"
    if (program >= 80 && program <= 95) return "Synth"
    if (program >= 0 && program <= 23) return "Keys/Piano"
    return "Other"
}

function groupTracksByRole(tracks) {
    const groups = {}
    tracks.filter(t => t.notes.length > 0).forEach(track => {
        const role = getRole(track.instrument.number, track.instrument.percussion)
        if (!groups[role]) groups[role] = []
        groups[role].push(track.instrument.name)
    })
    return groups
}

function formatTime(s) {
    return `${Math.floor(s/60).toString().padStart(2,'0')}:${Math.floor(s%60).toString().padStart(2,'0')}`
}

function midiToFreq(midi) { return 440 * Math.pow(2, (midi - 69) / 12) }

function getOscType(groupName, isPerc) {
    if (isPerc) return 'sine'
    if (groupName === 'Brass/Wind') return 'triangle'
    if (groupName === 'Strings' || groupName === 'Ensemble' || groupName === 'Choir') return 'sine'
    if (groupName === 'Bass') return 'triangle'
    return 'sine'
}

// ── PLAYER ─────────────────────────────────────────────────────────────────
let ctx = null, nodes = [], ticker = null
let playStart = 0, totalDur = 0, trackStart = 0
let currentTracks = [], currentGroup = null
let onTickFn = null, onStopFn = null

function killAll() {
    clearInterval(ticker); ticker = null
    nodes.forEach(n => { try { n.stop() } catch(e) {} try { n.disconnect() } catch(e) {} })
    nodes = []
}

function stopAll(cb) { killAll(); if (cb) cb() }

function scheduleNotes(tracks, groupName, seekOffset) {
    const now = ctx.currentTime + 0.1
    playStart = now - seekOffset

    tracks.forEach(track => {
        if (!track.notes.length) return
        const isPerc = track.instrument.percussion
        const type = getOscType(groupName, isPerc)

        track.notes.forEach(note => {
            const relTime = (note.time - trackStart) - seekOffset
            if (relTime < -0.01) return
            const at = now + Math.max(0, relTime)
            const dur = Math.max(note.duration, 0.05)
            const freq = isPerc ? 80 : midiToFreq(note.midi)
            const vol = note.velocity * 0.6

            const filter = ctx.createBiquadFilter()
            filter.type = 'lowpass'
            filter.frequency.value = groupName === 'Bass' ? 600 : groupName === 'Brass/Wind' ? 1800 : 5000
            filter.Q.value = 0.5
            filter.connect(ctx.destination)

            const gain = ctx.createGain()
            gain.gain.setValueAtTime(0, at)
            gain.gain.linearRampToValueAtTime(vol, at + (groupName === 'Strings' || groupName === 'Choir' ? 0.2 : 0.03))
            gain.gain.setValueAtTime(vol, at + dur * 0.75)
            gain.gain.linearRampToValueAtTime(0, at + dur + (groupName === 'Strings' ? 0.4 : 0.15))
            gain.connect(filter)

            const osc = ctx.createOscillator()
            osc.type = type
            osc.frequency.value = freq
            osc.connect(gain)
            osc.start(at)
            osc.stop(at + dur + 0.5)
            nodes.push(osc, gain, filter)
        })
    })

    ticker = setInterval(() => {
        const elapsed = ctx.currentTime - playStart
        if (onTickFn) onTickFn(Math.min(elapsed, totalDur), totalDur)
        if (elapsed >= totalDur) stopAll(onStopFn)
    }, 100)
}

async function play(tracks, groupName, onTick, onStop) {
    killAll()
    if (ctx) { try { await ctx.close() } catch(e) {} }
    ctx = new AudioContext()
    await ctx.resume()
    onTickFn = onTick; onStopFn = onStop
    currentTracks = tracks; currentGroup = groupName
    const allNotes = tracks.flatMap(t => t.notes)
    if (!allNotes.length) return
    trackStart = Math.min(...allNotes.map(n => n.time))
    totalDur = Math.max(...allNotes.map(n => n.time + n.duration)) - trackStart
    scheduleNotes(tracks, groupName, 0)
}

async function seek(fraction) {
    if (!currentTracks.length) return
    killAll()
    if (ctx) { try { await ctx.close() } catch(e) {} }
    ctx = new AudioContext()
    await ctx.resume()
    scheduleNotes(currentTracks, currentGroup, Math.max(0, Math.min(1, fraction)) * totalDur)
}

// ── UI ─────────────────────────────────────────────────────────────────────
const nowPlaying = document.getElementById('now-playing')
const progressBar = document.getElementById('progress-bar')
const progressWrap = document.getElementById('progress-wrap')
const scrubber = document.getElementById('scrubber')
const timeDisplay = document.getElementById('time-display')

function resetBar() {
    progressBar.style.width = '0%'; scrubber.style.left = '0%'
    timeDisplay.textContent = '00:00 / 00:00'; timeDisplay.classList.remove('active')
    nowPlaying.textContent = '—'; nowPlaying.classList.remove('active')
}

progressWrap.addEventListener('click', async (e) => {
    const rect = progressWrap.getBoundingClientRect()
    await seek((e.clientX - rect.left) / rect.width)
})
progressWrap.addEventListener('mousemove', (e) => {
    const rect = progressWrap.getBoundingClientRect()
    scrubber.style.left = `${Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100))}%`
})

async function loadMidis() {
    const app = document.getElementById('app')
    const res = await fetch('midi/index.json')
    const files = await res.json()
    app.innerHTML = ''

    for (const file of files) {
        const data = await fetch(`midi/${file}`)
        const buffer = await data.arrayBuffer()
        const midi = new Midi(buffer)
        const groups = groupTracksByRole(midi.tracks)
        const tracksByGroup = {}
        midi.tracks.filter(t => t.notes.length > 0).forEach(track => {
            const role = getRole(track.instrument.number, track.instrument.percussion)
            if (!tracksByGroup[role]) tracksByGroup[role] = []
            tracksByGroup[role].push(track)
        })

        const section = document.createElement('div')
        section.innerHTML = `<div class="groups"></div>`
        app.appendChild(section)
        const groupsEl = section.querySelector('.groups')

        for (const [role, instruments] of Object.entries(groups)) {
            const row = document.createElement('div')
            row.className = 'group-row'
            row.innerHTML = `
                <div class="indicator"></div>
                <div class="group-name">${role}</div>
                <div class="instruments">${instruments.join(', ')}</div>
                <button class="btn">Play</button>
            `
            const btn = row.querySelector('.btn')
            btn.addEventListener('click', async () => {
                const wasPlaying = row.classList.contains('playing')
                document.querySelectorAll('.group-row').forEach(r => {
                    r.classList.remove('playing'); r.querySelector('.btn').textContent = 'Play'
                })
                if (wasPlaying) { stopAll(); resetBar(); return }
                row.classList.add('playing'); btn.textContent = 'Stop'
                await play(tracksByGroup[role] || [], role,
                    (elapsed, duration) => {
                        const pct = Math.min((elapsed / duration) * 100, 100)
                        progressBar.style.width = `${pct}%`; scrubber.style.left = `${pct}%`
                        timeDisplay.textContent = `${formatTime(elapsed)} / ${formatTime(duration)}`
                        timeDisplay.classList.add('active')
                        nowPlaying.textContent = role; nowPlaying.classList.add('active')
                    },
                    () => { row.classList.remove('playing'); btn.textContent = 'Play'; resetBar() }
                )
            })
            groupsEl.appendChild(row)
        }
    }
}

loadMidis()
</script>
</body>
</html>
