---
phase: 02-build-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - MusicSplit/build.py
  - .gitignore
autonomous: true
requirements:
  - BUILD-01
  - BUILD-02
  - BUILD-03
  - BUILD-04

must_haves:
  truths:
    - "Running `python build.py` from MusicSplit/ with a soundfont and test.mid produces per-group MP3s in audio/<song-id>/"
    - "Running `python build.py` produces cumulative layer MP3s where layer-N contains groups 1 through N mixed together"
    - "Running `python build.py` produces a songs.js manifest with title, artist, id, groups, and layers for each song"
    - "Empty instrument groups are flagged as present:false in the manifest and excluded from cumulative layers"
    - "Each per-group and cumulative MP3 is trimmed to ~60 seconds at 192kbps stereo"
  artifacts:
    - path: "MusicSplit/build.py"
      provides: "Complete MIDI-to-MP3 build pipeline"
      min_lines: 150
      contains: "get_group_index"
    - path: "MusicSplit/audio/"
      provides: "Output directory for per-song audio files"
    - path: "MusicSplit/songs.js"
      provides: "Song manifest with const SONGS = [...] format"
      contains: "const SONGS"
  key_links:
    - from: "MusicSplit/build.py"
      to: "mido + pretty_midi"
      via: "MIDI channel/program parsing"
      pattern: "mido\\.MidiFile|program_change"
    - from: "MusicSplit/build.py"
      to: "FluidSynth CLI"
      via: "subprocess.run for MIDI-to-WAV rendering"
      pattern: "fluidsynth.*-ni.*-F"
    - from: "MusicSplit/build.py"
      to: "ffmpeg CLI"
      via: "subprocess.run for WAV-to-MP3 and amix"
      pattern: "ffmpeg.*-b:a.*192k"
    - from: "MusicSplit/build.py"
      to: "MusicSplit/songs.js"
      via: "json.dumps manifest write"
      pattern: "const SONGS"
---

<objective>
Build the complete Python pipeline that converts MIDI files into per-instrument-group MP3s, cumulative layer MP3s, and a songs.js manifest.

Purpose: The MusicSplit game needs real audio assets (not oscillator tones) to function. This pipeline is the prerequisite for all game code in Phase 3.
Output: `MusicSplit/build.py` script, `.gitignore` updates, verified audio output from test.mid
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-build-pipeline/02-CONTEXT.md
@.planning/phases/02-build-pipeline/02-RESEARCH.md

@MusicSplit/utils.js (getRole mapping — translate to Python)
@Music01s/build.py (canonical build script pattern to follow)
@MusicSplit/details_midi.py (pretty_midi usage pattern)

<interfaces>
<!-- Existing patterns the executor needs. -->

From Music01s/build.py (manifest pattern):
```python
# Scan -> process -> generate manifest
# songs.js format: "const SONGS = " + json.dumps(songs, indent=2) + ";\n"
# subprocess.run for ffmpeg with stdout=DEVNULL, stderr=DEVNULL
```

From MusicSplit/utils.js (getRole — authoritative group mapping):
```javascript
export function getRole(program, isPercussion) {
    if (program >= 32 && program <= 39) return "Bass"
    if (program >= 24 && program <= 31) return "Guitar"
    if (program >= 40 && program <= 46) return "Strings"  // 47 excluded
    if (program === 47) return "Percussion"               // Timpani
    if (program >= 48 && program <= 51) return "Ensemble"
    if (program >= 52 && program <= 54) return "Choir"
    if (program === 55) return "Percussion"               // Orchestra Hit
    if (program >= 56 && program <= 71) return "Brass/Wind"
    if (program >= 80 && program <= 95) return "Synth"
    if (program >= 0  && program <= 23) return "Keys/Piano"
}
```

Merged into 6 groups (per user decision):
1. Drums+Perc: is_drum=true OR programs 47, 55
2. Bass: programs 32-39
3. Brass/Wind: programs 56-71
4. Keys/Piano+Synth: programs 0-23, 80-95 (+ unmapped "Other" fallback)
5. Guitar: programs 24-31
6. Ensemble+Choir+Strings: programs 40-54 (excluding 47, 55)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MusicSplit/build.py with full MIDI-to-MP3 pipeline</name>
  <files>MusicSplit/build.py</files>
  <action>
Create `MusicSplit/build.py` — the complete build pipeline script. Follow the Music01s/build.py scan-process-manifest pattern. The script does everything in one file (~200-250 lines).

**Structure (in order):**

1. **Constants and group definitions:**
   - GROUP_NAMES list with 6 entries in fixed order: Drums+Perc, Bass, Brass/Wind, Keys/Piano+Synth, Guitar, Ensemble+Choir+Strings
   - GROUP_META list with index, name, and slug (e.g., "group-1-drums", "group-2-bass", etc.)
   - MIDI_DIR = "midi", AUDIO_DIR = "audio", SONGS_JS = "songs.js"
   - SOUNDFONT_SEARCH_PATHS list (see Research Pattern 7)
   - SOUNDFONT_ERROR message with download instructions for GeneralUser GS

2. **`get_group_index(program, is_drum)` function:**
   - Translate the utils.js getRole() mapping into Python with the 3 merges:
     - is_drum -> 0 (Drums+Perc)
     - programs 47, 55 -> 0 (Timpani, Orchestra Hit -> Drums+Perc)
     - 32-39 -> 1 (Bass)
     - 56-71 -> 2 (Brass/Wind)
     - 0-23 OR 80-95 -> 3 (Keys/Piano+Synth)
     - 24-31 -> 4 (Guitar)
     - 40-54 -> 5 (Ensemble+Choir+Strings) — note 47,55 already caught above
     - Anything else -> 3 (fallback to Keys/Piano)

3. **`find_soundfont()` function:**
   - Search SOUNDFONT_SEARCH_PATHS (next to build.py, ~/.fluidsynth/, Homebrew locations, Linux standard)
   - Use glob.glob for wildcard patterns, os.path.isfile for exact paths
   - Raise SystemExit with SOUNDFONT_ERROR if none found
   - Also accept --soundfont CLI argument (argparse or sys.argv) to override search

4. **`get_channel_programs(midi_path)` function:**
   - Use mido.MidiFile to read the MIDI
   - Iterate all tracks/messages, collect program_change: channel -> program
   - Count note_on messages per channel (velocity > 0)
   - Channel 9 is always drums (set program to None sentinel)
   - Return (channel_programs dict, note_counts dict)

5. **`build_group_channels(channel_programs, note_counts)` function:**
   - Map each channel to a group index via get_group_index
   - Return groups dict (group_index -> set of channels) and non_empty dict (group_index -> bool based on note count > 0)

6. **`write_group_midi(src_path, dst_path, keep_channels)` function:**
   - Use mido to write filtered MIDI containing only keep_channels
   - Preserve meta messages (no channel attribute) always
   - Keep track 0 always (tempo/time sig metadata)
   - Keep other tracks only if they contain messages for keep_channels

7. **`render_midi_to_wav(midi_path, wav_path, soundfont_path)` function:**
   - subprocess.run: fluidsynth -ni -F wav_path -T wav -r 44100 soundfont_path midi_path
   - stderr=DEVNULL (FluidSynth 2.x emits harmless panic messages)
   - check=True to catch actual failures

8. **`wav_to_mp3(wav_path, mp3_path, duration=60)` function:**
   - subprocess.run: ffmpeg -y -i wav_path -t duration -ar 44100 -ac 2 -b:a 192k mp3_path
   - check=True

9. **`mix_wavs_to_mp3(wav_paths, mp3_path, duration=60)` function:**
   - If single input, delegate to wav_to_mp3
   - Multiple inputs: ffmpeg -y -i wav1 -i wav2 ... -t duration -filter_complex "amix=inputs=N:duration=longest:normalize=0" -ar 44100 -ac 2 -b:a 192k mp3_path
   - check=True

10. **`make_song_id(filename)` and `parse_filename(filename)` functions:**
    - make_song_id: strip .mid extension, lowercase, replace whitespace/underscores/dots with hyphens, remove non-alphanumeric chars except hyphens, collapse multiple hyphens
    - parse_filename: split on " - " to get (artist, title); if no separator, artist=None, title=full name

11. **`process_song(midi_path, midi_filename, song_id, out_dir, soundfont)` function:**
    - Use tempfile.TemporaryDirectory for intermediate WAV files
    - Step A: get_channel_programs + build_group_channels to detect groups
    - Step B: For each of the 6 groups, write filtered MIDI to temp, render to WAV in temp. Track which groups are non-empty.
    - Step C: For each non-empty group, convert per-group WAV to per-group MP3 in out_dir (e.g., group-1-drums.mp3). Also render empty groups to MP3 (silence is fine for explorer mode).
    - Step D: Build cumulative layers. For each present group in order, accumulate its WAV into the mix list. Call mix_wavs_to_mp3 with the accumulated WAVs -> layer-N.mp3 in out_dir. Only increment layer number for present groups.
    - Step E: Build and return the song manifest entry dict: { id, title, artist, groups: [{name, file, present}], layers: [cumulative mp3 paths] }
    - Use try/finally to ensure temp dir cleanup

12. **`write_manifest(songs, output_path)` function:**
    - Write "// Auto-generated by build.py\n" + "const SONGS = " + json.dumps(songs, indent=2, ensure_ascii=False) + ";\n"

13. **`main()` function:**
    - find_soundfont() (optionally accept --soundfont arg)
    - os.makedirs(AUDIO_DIR, exist_ok=True)
    - List and sort .mid/.midi files from MIDI_DIR
    - For each file: process_song wrapped in try/except, collect failures
    - write_manifest with all successful songs
    - Print summary: N songs written, M failed (with details)

14. **`if __name__ == "__main__": main()`**

**Important implementation notes:**
- Use mido for channel->program mapping (NOT pretty_midi — see Pitfall 2 in Research)
- Channel 9 is always drums regardless of program_change messages
- If no program_change for a channel with notes, assume program 0 (Acoustic Grand Piano -> group 3)
- All per-group WAVs from FluidSynth will have the same duration (full MIDI length), so -t 60 trim produces identical-length MP3s
- Always render per-group MP3 even for empty groups (silent file for explorer mode)
- Only include present groups in cumulative layers
  </action>
  <verify>
    <automated>cd /Users/pierremarsaa/Desktop/Projet/WEB/RandomGame/MusicSplit && python -c "import build; print('imports OK')" && python -c "from build import get_group_index; assert get_group_index(0, False)==3; assert get_group_index(35, False)==1; assert get_group_index(0, True)==0; assert get_group_index(47, False)==0; assert get_group_index(60, False)==2; assert get_group_index(25, False)==4; assert get_group_index(45, False)==5; print('group mapping OK')"</automated>
  </verify>
  <done>build.py exists with all 13 functions, imports cleanly, get_group_index maps correctly for all 6 groups plus fallback</done>
</task>

<task type="auto">
  <name>Task 2: Update .gitignore and run build.py against test.mid to verify end-to-end</name>
  <files>.gitignore, MusicSplit/audio/, MusicSplit/songs.js</files>
  <action>
**Step 1: Update .gitignore**

Add these entries to the existing .gitignore:
- `*.sf2` — soundfont files (large binaries, not committed)
- `MusicSplit/audio/` — generated MP3 output (build artifacts)

Do NOT remove existing entries. Append to the file.

**Step 2: Run build.py against test.mid**

Run the build script from MusicSplit/ directory. The test.mid file already exists in MusicSplit/midi/.

If no soundfont is found automatically, the script should error with instructions. In that case:
- Check if FluidR3_GM.sf2 exists anywhere on the machine: `find /usr/local -name "*.sf2" 2>/dev/null` and `find /opt -name "*.sf2" 2>/dev/null`
- If found, pass it via --soundfont flag or copy/symlink to MusicSplit/
- If not found, create a checkpoint:human-action to ask the user to download a soundfont

Run: `cd MusicSplit && python build.py` (or `python build.py --soundfont /path/to/soundfont.sf2`)

**Step 3: Verify outputs**

After successful build, verify:
1. `MusicSplit/audio/` directory exists with a subdirectory for test.mid's song ID
2. Per-group MP3 files exist: group-1-drums.mp3 through group-6-ensemble-choir-strings.mp3
3. Cumulative layer MP3 files exist: layer-1.mp3, layer-2.mp3, etc. (count depends on how many groups are present in test.mid)
4. `MusicSplit/songs.js` exists and starts with "// Auto-generated by build.py" followed by "const SONGS = ["
5. The manifest entry has correct structure: id, title, artist, groups (6 entries), layers array
6. All MP3 files are roughly the same size (same duration, same bitrate)
7. MP3 files are valid: `ffprobe -i <mp3> -show_entries format=duration,bit_rate -v quiet -of csv=p=0` should show ~60s duration and ~192000 bitrate

**Step 4: Verify songs.js content**

Check that songs.js:
- Has `const SONGS = [...]` format (not JSON, not export)
- Each song entry has: id (string), title (string), artist (string or null), groups (array of 6), layers (array)
- Each group entry has: name (string), file (string path), present (boolean)
- layers array only contains paths for present groups

Print a summary of the test results.
  </action>
  <verify>
    <automated>cd /Users/pierremarsaa/Desktop/Projet/WEB/RandomGame && grep -q "*.sf2" .gitignore && grep -q "MusicSplit/audio/" .gitignore && test -f MusicSplit/songs.js && grep -q "const SONGS" MusicSplit/songs.js && echo "ALL CHECKS PASSED"</automated>
  </verify>
  <done>.gitignore updated with sf2 and audio exclusions; build.py ran successfully against test.mid; audio/<song-id>/ contains per-group and cumulative MP3s; songs.js has valid manifest with correct structure</done>
</task>

</tasks>

<verification>
End-to-end phase verification:

1. `cd MusicSplit && python build.py` completes without errors (soundfont must be available)
2. `ls audio/*/group-*.mp3 | wc -l` shows 6 per-group files per song
3. `ls audio/*/layer-*.mp3 | wc -l` shows N cumulative layer files (N = number of non-empty groups)
4. `head -2 songs.js` shows "// Auto-generated by build.py" and "const SONGS = ["
5. `python -c "import json; exec(open('songs.js').read().replace('const SONGS = ','SONGS = ').rstrip(';\n')); print(len(SONGS), 'songs'); [print(s['id'], len(s['layers']), 'layers') for s in SONGS]"` parses and shows song count + layer count
6. `ffprobe -i audio/*/layer-1.mp3 -show_entries format=duration -v quiet -of csv=p=0` shows ~60 seconds
</verification>

<success_criteria>
- build.py runs end-to-end on test.mid producing valid MP3 outputs
- 6 per-group MP3 files exist per song (some may be silent for empty groups)
- Cumulative layer MP3s exist (only for present groups, mixed correctly)
- songs.js manifest has correct `const SONGS = [...]` format with all required fields
- .gitignore excludes soundfont files and generated audio
- All MP3 files are ~60s, 192kbps, stereo
</success_criteria>

<output>
After completion, create `.planning/phases/02-build-pipeline/02-01-SUMMARY.md`
</output>
